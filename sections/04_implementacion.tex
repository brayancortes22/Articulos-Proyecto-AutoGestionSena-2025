\section{Requisitos Técnicos del Sistema}

Para desarrollar el sistema usamos herramientas específicas con versiones controladas para asegurar que todo funcionara bien. Los requisitos se pensaron para seguir buenas prácticas y cubrir las necesidades del proyecto.

\textbf{Requisitos de Hardware:}
\begin{itemize}
\item Procesador: Intel Core i5/i7 o similar (mínimo Core i3)
\item Memoria RAM: 16 GB recomendado (mínimo 8 GB)
\item Almacenamiento: Disco SSD con 20 GB libres (mínimo 10 GB)
\item Conexión a internet estable para desarrollo y despliegue
\end{itemize}

\textbf{Requisitos de Software por Componente:}

\textit{Parte back-end (Python/Django):}
\begin{itemize}
\item Python 3.10 o superior
\item Django 4.2.23
\item MySQL 8.x / MariaDB 10.x
\item Redis 6.x o superior
\item Celery 5.x con django-celery-beat 2.x
\item Git 2.49.0 para control de versiones
\end{itemize}

\textit{Parte web (React/TypeScript):}
\begin{itemize}
\item Node.js 20.19.0
\item TypeScript 5.8.3
\item React 18.3.1
\item Tailwind CSS 3.4.17
\item Vite 5.4.19
\item Navegador moderno (Chrome/Edge/Firefox última versión)
\end{itemize}

\textit{Aplicación móvil (.NET MAUI):}
\begin{itemize}
\item .NET SDK 9.0
\item Visual Studio 2022 17.8+
\item Paquete .NET MAUI
\item Android SDK API 29+ (recomendado), mínimo API 23
\end{itemize}

\textbf{Compatibilidad de Dispositivos Móviles:}
\begin{itemize}
\item Android: Versión mínima 6.0 (API 23), recomendado 10+ (API 29)
\item Pantallas soportadas: 320x480 hasta 1440x3040 píxeles
\item Arquitecturas: ARM64, ARM32, x86\_64
\end{itemize}

Estos requisitos técnicos se probaron durante el desarrollo para asegurar que el sistema funcionara bien en diferentes entornos y dispositivos.

\section{Desarrollo del Backend con Django}

La parte back-end se reestructuró usando Django 4.2.23 con Django REST Framework 3.16.0, siguiendo una arquitectura de capas basada en módulos donde cada parte del sistema tiene sus propias capas de datos, lógica y presentación. Esto ayuda a separar responsabilidades, mantener el código organizado y hacer fácil actualizar el sistema. Tomamos el Backend existente y lo modernizamos completamente con mejores prácticas y tecnologías actualizadas.

Tecnologías de la parte back-end:
\begin{itemize}
\item Python 3.10 como lenguaje principal
\item Django 4.2.23 como framework principal con base de datos integrada
\item Django REST Framework 3.16.0 para crear APIs REST
\item MySQL 8.x como base de datos para guardar información
\item Redis 5.2.1 como sistema de cache y mensajes
\item Celery 5.5.3 para tareas en segundo plano
\item Documentación automática con Swagger/drf-yasg 1.21.10
\item Autenticación JWT con djangorestframework-simplejwt
\end{itemize}

La arquitectura back-end se organiza en módulos independientes (seguridad, general, asignación) con conexiones expuestas bajo /api/. Cada módulo usa ViewSets y routers de DRF, con autenticación JWT disponible en POST /api/token/ y POST /api/token/refresh/.

La IA ayudó mucho en la parte back-end, siendo responsable de aproximadamente el 60\% del código. Específicamente, la IA ayudó en:
\begin{itemize}
\item Crear modelos Django con relaciones complejas (ForeignKey, ManyToMany) entre usuarios, roles, estudiantes e instructores
\item Hacer validaciones personalizadas y reglas para mantener la calidad de los datos
\item Crear serializadores anidados para respuestas API complejas con relaciones
\item Desarrollar ViewSets genéricos y personalizados con control de permisos
\item Implementar algoritmos de asignación automática usando optimización
\item Configurar autenticación JWT con tokens de refresh y middleware de seguridad
\item Generar documentación OpenAPI automática con ejemplos de uso
\item Crear tareas asíncronas con Celery para procesamiento en background
\end{itemize}

Esta ayuda permitió reducir mucho el tiempo de desarrollo de la parte back-end, pasando de meses estimados a semanas, manteniendo calidad y siguiendo buenas prácticas de Django y DRF.

\section{Desarrollo del Frontend Web con React}

El frontend se reestructuró completamente como una Single Page Application utilizando React 18.3.1 con TypeScript 5.8.3, siguiendo una arquitectura modular y organizada por funcionalidades (feature-based). La aplicación está estructurada con separación clara entre vista, lógica y comunicación, utilizando componentes reutilizables, hooks personalizados y servicios centralizados. Tomamos la interfaz existente y la rediseñamos desde cero con tecnologías modernas.

Stack Tecnológico Frontend:
\begin{itemize}
\item React 18.3.1 como librería principal para interfaces dinámicas basadas en componentes
\item TypeScript 5.8.3 para tipado estático y detección temprana de errores
\item Tailwind CSS 3.4.17 como framework CSS utilitario para diseño responsivo
\item Vite 5.4.19 como herramienta de desarrollo rápida para compilación y optimización
\item Node.js 20.19.0 como entorno de ejecución para desarrollo y gestión de dependencias
\item Fetch API nativa para comunicación HTTP con el backend
\item LocalStorage/SessionStorage para persistencia de sesión y datos temporales
\item JSON como formato estándar de intercambio de datos
\end{itemize}

La arquitectura frontend opera bajo principios de separación de responsabilidades: las vistas (pages) utilizan componentes reutilizables (components), la lógica se encapsula en hooks personalizados, y la comunicación con APIs se gestiona desde servicios centralizados. Las rutas privadas pasan por componentes de protección (ProtectedRoute, ProtectedLayout) que validan autenticación y permisos.

La IA fue fundamental en el desarrollo del frontend, contribuyendo al 75\% del código implementado. Sus aportes incluyeron:
\begin{itemize}
\item Generación de componentes funcionales con hooks personalizados (useState, useEffect, useContext) para gestión de estado complejo
\item Implementación de formularios con validación robusta utilizando React Hook Form y Zod para schemas de validación
\item Creación de tablas de datos con funcionalidades avanzadas usando TanStack Table para filtrado, paginación y ordenamiento
\item Desarrollo de dashboards administrativos con gráficos interactivos utilizando Chart.js o D3.js
\item Optimización de rendimiento mediante React.memo, useMemo, useCallback y lazy loading con React.lazy
\item Implementación de navegación protegida con React Router v6 y guards de autenticación
\item Creación de servicios API con interceptores para manejo automático de tokens JWT y refresh
\item Desarrollo de componentes reutilizables siguiendo el patrón de diseño atómico (átomos, moléculas, organismos)
\end{itemize}

La IA también asistió en la resolución de problemas complejos de UI/UX, sugiriendo mejoras de accesibilidad WCAG 2.1, implementando diseños responsive con CSS Grid y Flexbox, y proponiendo arquitecturas de estado eficientes con Context API o Redux Toolkit.

\section{Desarrollo de la Aplicación Móvil con .NET MAUI}

La aplicación móvil se reestructuró usando .NET MAUI 9.0 con C\# 12, siguiendo el patrón Model-View-ViewModel (MVVM) que ayuda a separar responsabilidades, mantener el código y hacer pruebas. La app se enfocó primero en Android, pero puede funcionar en Windows después. Tomamos una aplicación móvil básica existente y la transformamos completamente con una arquitectura moderna y mejores funcionalidades.

Tecnologías de la aplicación móvil:
\begin{itemize}
\item .NET MAUI 9.0 como framework para desarrollo en múltiples plataformas
\item C\# 12 como lenguaje principal para lógica y interfaces
\item XAML como lenguaje para diseñar las pantallas
\item Visual Studio 2022 17.8+ como entorno de desarrollo
\item CommunityToolkit.Mvvm para implementar el patrón MVVM
\item HttpClient para conectar con APIs
\end{itemize}

El patrón MVVM divide la app en tres partes:
\begin{itemize}
\item Modelo: Capa de datos con objetos de transferencia y servicios para APIs
\item Vista: Capa de interfaz con archivos XAML y poco código adicional
\item ViewModel: Conexión entre vista y modelo con propiedades y acciones
\end{itemize}

En el desarrollo móvil, la IA representó el 65\% del código. Sus aportes principales fueron:
\begin{itemize}
\item Crear ViewModels con propiedades que cambian y acciones asíncronas
\item Conectar vistas XAML con lógica usando CommunityToolkit.Mvvm
\item Hacer diseños adaptables con diferentes tipos de layout para pantallas Android
\item Manejar navegación entre páginas con parámetros
\item Crear servicios para APIs con manejo de errores
\item Hacer validaciones de formularios con mensajes visuales
\item Crear componentes reutilizables como menús
\end{itemize}

La IA ayudó al equipo a pasar del desarrollo web al móvil, dando ejemplos de XAML, explicando conceptos de .NET MAUI y resolviendo problemas de compatibilidad.

\section{Integración y Despliegue con Docker}

El sistema se recontenerizó utilizando Docker para garantizar consistencia entre entornos de desarrollo, staging y producción. La configuración incluyó múltiples servicios interconectados con redes personalizadas, volúmenes persistentes para bases de datos, y variables de entorno para configuración segura.

Arquitectura de Contenedores:
\begin{itemize}
\item Contenedor backend: Django con Gunicorn como servidor, disponible en puerto 8000
\item Contenedor frontend: Nginx sirviendo archivos de React, disponible en puerto 80
\item Contenedor base de datos: MySQL 8.x con datos guardados permanentemente
\item Contenedor caché: Redis 6.x para guardar datos temporales y mensajes
\item Contenedor trabajador: Procesos de Celery para tareas en segundo plano
\item Contenedor proxy: Nginx como intermediario con balanceo de carga
\end{itemize}

La configuración de docker-compose incluye revisiones de salud para servicios importantes, reinicios automáticos y dependencias para que todo arranque en orden. Los volúmenes nombrados mantienen los datos de MySQL y Redis.

La IA ayudó mucho en el despliegue, siendo responsable del 80\% de la configuración. Esto incluyó:
\begin{itemize}
\item Crear archivos Dockerfile optimizados en varias etapas
\item Configurar docker-compose con redes y servicios conectados
\item Usar variables de entorno para diferentes ambientes
\item Estrategias de despliegue con revisiones de salud y reinicios
\item Configurar Nginx como intermediario con límites de velocidad y seguridad
\end{itemize}